# Запрос №5: Сформировать схему зала и показать на ней свободные и занятые места на конкретный сеанс

## Оптимизация

Добавлены индексы на колонки, которые используются в качестве внешних ключей:

- `sessions.hall_id`
- `hall_seats.hall_id`
- `sales.session_id`
- `sales.seat_id`

## 1.000 записей

До оптимизации:

```postgresql
Nested Loop Left Join  (cost=8.73..15.31 rows=1 width=521) (actual time=0.060..0.063 rows=0 loops=1)
   Join Filter: (sales.session_id = sessions.id)
   ->  Nested Loop  (cost=8.46..14.36 rows=1 width=536) (actual time=0.058..0.061 rows=0 loops=1)
         Join Filter: (sessions.hall_id = halls.id)
         ->  Hash Join  (cost=8.30..10.92 rows=33 width=24) (actual time=0.057..0.059 rows=0 loops=1)
               Hash Cond: (hall_seats.hall_id = sessions.hall_id)
               ->  Seq Scan on hall_seats  (cost=0.00..1.99 rows=99 width=14) (actual time=0.017..0.018 rows=1 loops=1)
               ->  Hash  (cost=8.29..8.29 rows=1 width=10) (actual time=0.024..0.024 rows=0 loops=1)
                     Buckets: 1024  Batches: 1  Memory Usage: 8kB
                     ->  Index Scan using sessions_pkey on sessions  (cost=0.28..8.29 rows=1 width=10) (actual time=0.022..0.022 rows=0 loops=1)
                           Index Cond: (id = 2001)
         ->  Memoize  (cost=0.15..0.66 rows=1 width=518) (never executed)
               Cache Key: hall_seats.hall_id
               Cache Mode: logical
               ->  Index Scan using halls_pkey on halls  (cost=0.14..0.65 rows=1 width=518) (never executed)
                     Index Cond: (id = hall_seats.hall_id)
   ->  Index Only Scan using sales_session_id_seat_id_key on sales  (cost=0.28..0.94 rows=1 width=16) (never executed)
         Index Cond: ((session_id = 2001) AND (seat_id = hall_seats.id))
         Heap Fetches: 0

Planning Time: 2.587 ms
Execution Time: 0.200 ms

(21 rows)
```

После оптимизации:

```postgresql
Hash Left Join  (cost=17.68..20.54 rows=33 width=7) (actual time=0.097..0.100 rows=0 loops=1)
   Hash Cond: ((sessions.id = sales.session_id) AND (hall_seats.id = sales.seat_id))
   ->  Hash Join  (cost=9.37..12.06 rows=33 width=22) (actual time=0.095..0.097 rows=0 loops=1)
         Hash Cond: (hall_seats.hall_id = sessions.hall_id)
         ->  Seq Scan on hall_seats  (cost=0.00..1.99 rows=99 width=14) (actual time=0.027..0.027 rows=1 loops=1)
         ->  Hash  (cost=9.36..9.36 rows=1 width=14) (actual time=0.038..0.039 rows=0 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 8kB
               ->  Nested Loop  (cost=0.28..9.36 rows=1 width=14) (actual time=0.037..0.037 rows=0 loops=1)
                     Join Filter: (halls.id = sessions.hall_id)
                     ->  Index Scan using sessions_pkey on sessions  (cost=0.28..8.29 rows=1 width=10) (actual time=0.037..0.037 rows=0 loops=1)
                           Index Cond: (id = 2001)
                     ->  Seq Scan on halls  (cost=0.00..1.03 rows=3 width=4) (never executed)
   ->  Hash  (cost=8.29..8.29 rows=1 width=16) (never executed)
         ->  Index Only Scan using sales_session_id_seat_id_key on sales  (cost=0.28..8.29 rows=1 width=16) (never executed)
               Index Cond: (session_id = 2001)
               Heap Fetches: 0

Planning Time: 1.745 ms
Execution Time: 1.896 ms

(18 rows)
```

Комментарий:

"Стоимость" запроса увеличилась, скорость ответа стала немного медленней.

## 10.000 записей

До оптимизации:

```postgresql
Hash Left Join  (cost=13.70..16.56 rows=33 width=7) (actual time=0.121..0.152 rows=27 loops=1)
   Hash Cond: ((sessions.id = sales.session_id) AND (hall_seats.id = sales.seat_id))
   ->  Hash Join  (cost=9.38..12.07 rows=33 width=22) (actual time=0.092..0.115 rows=27 loops=1)
         Hash Cond: (hall_seats.hall_id = sessions.hall_id)
         ->  Seq Scan on hall_seats  (cost=0.00..1.99 rows=99 width=14) (actual time=0.015..0.024 rows=99 loops=1)
         ->  Hash  (cost=9.37..9.37 rows=1 width=14) (actual time=0.048..0.049 rows=1 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Nested Loop  (cost=0.29..9.37 rows=1 width=14) (actual time=0.036..0.037 rows=1 loops=1)
                     Join Filter: (halls.id = sessions.hall_id)
                     Rows Removed by Join Filter: 1
                     ->  Index Scan using sessions_pkey on sessions  (cost=0.29..8.30 rows=1 width=10) (actual time=0.020..0.021 rows=1 loops=1)
                           Index Cond: (id = 2001)
                     ->  Seq Scan on halls  (cost=0.00..1.03 rows=3 width=4) (actual time=0.001..0.001 rows=2 loops=1)
   ->  Hash  (cost=4.30..4.30 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: 8kB
         ->  Index Only Scan using sales_session_id_seat_id_key on sales  (cost=0.29..4.30 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
               Index Cond: (session_id = 2001)
               Heap Fetches: 0

Planning Time: 1.172 ms
Execution Time: 0.254 ms

(20 rows)
```

После оптимизации:

```postgresql
Hash Left Join  (cost=13.70..16.56 rows=33 width=7) (actual time=0.126..0.159 rows=27 loops=1)
   Hash Cond: ((sessions.id = sales.session_id) AND (hall_seats.id = sales.seat_id))
   ->  Hash Join  (cost=9.38..12.07 rows=33 width=22) (actual time=0.096..0.120 rows=27 loops=1)
         Hash Cond: (hall_seats.hall_id = sessions.hall_id)
         ->  Seq Scan on hall_seats  (cost=0.00..1.99 rows=99 width=14) (actual time=0.014..0.023 rows=99 loops=1)
         ->  Hash  (cost=9.37..9.37 rows=1 width=14) (actual time=0.053..0.054 rows=1 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Nested Loop  (cost=0.29..9.37 rows=1 width=14) (actual time=0.040..0.041 rows=1 loops=1)
                     Join Filter: (halls.id = sessions.hall_id)
                     Rows Removed by Join Filter: 1
                     ->  Index Scan using sessions_pkey on sessions  (cost=0.29..8.30 rows=1 width=10) (actual time=0.024..0.025 rows=1 loops=1)
                           Index Cond: (id = 2001)
                     ->  Seq Scan on halls  (cost=0.00..1.03 rows=3 width=4) (actual time=0.001..0.001 rows=2 loops=1)
   ->  Hash  (cost=4.30..4.30 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: 8kB
         ->  Index Only Scan using sales_session_id_seat_id_key on sales  (cost=0.29..4.30 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
               Index Cond: (session_id = 2001)
               Heap Fetches: 0

Planning Time: 2.405 ms
Execution Time: 0.268 ms

(20 rows)
```

Комментарий:

"Стоимость" запроса не изменилась, скорость ответа стала немного медленней.

## 100.000 записей

До оптимизации:

```postgresql
Hash Left Join  (cost=13.87..16.74 rows=33 width=7) (actual time=0.165..0.226 rows=18 loops=1)
   Hash Cond: ((sessions.id = sales.session_id) AND (hall_seats.id = sales.seat_id))
   ->  Hash Join  (cost=9.39..12.08 rows=33 width=22) (actual time=0.117..0.166 rows=18 loops=1)
         Hash Cond: (hall_seats.hall_id = sessions.hall_id)
         ->  Seq Scan on hall_seats  (cost=0.00..1.99 rows=99 width=14) (actual time=0.019..0.036 rows=99 loops=1)
         ->  Hash  (cost=9.38..9.38 rows=1 width=14) (actual time=0.070..0.072 rows=1 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Nested Loop  (cost=0.29..9.38 rows=1 width=14) (actual time=0.056..0.058 rows=1 loops=1)
                     Join Filter: (halls.id = sessions.hall_id)
                     ->  Index Scan using sessions_pkey on sessions  (cost=0.29..8.31 rows=1 width=10) (actual time=0.035..0.036 rows=1 loops=1)
                           Index Cond: (id = 2001)
                     ->  Seq Scan on halls  (cost=0.00..1.03 rows=3 width=4) (actual time=0.003..0.003 rows=1 loops=1)
   ->  Hash  (cost=4.45..4.45 rows=2 width=16) (actual time=0.033..0.034 rows=0 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: 8kB
         ->  Index Only Scan using sales_session_id_seat_id_key on sales  (cost=0.42..4.45 rows=2 width=16) (actual time=0.033..0.033 rows=0 loops=1)
               Index Cond: (session_id = 2001)
               Heap Fetches: 0

Planning Time: 1.842 ms
Execution Time: 0.382 ms

(19 rows)
```

После оптимизации:

```postgresql
 Hash Left Join  (cost=13.87..16.74 rows=33 width=7) (actual time=0.047..0.075 rows=18 loops=1)
   Hash Cond: ((sessions.id = sales.session_id) AND (hall_seats.id = sales.seat_id))
   ->  Hash Join  (cost=9.39..12.08 rows=33 width=22) (actual time=0.034..0.057 rows=18 loops=1)
         Hash Cond: (hall_seats.hall_id = sessions.hall_id)
         ->  Seq Scan on hall_seats  (cost=0.00..1.99 rows=99 width=14) (actual time=0.007..0.015 rows=99 loops=1)
         ->  Hash  (cost=9.38..9.38 rows=1 width=14) (actual time=0.019..0.020 rows=1 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Nested Loop  (cost=0.29..9.38 rows=1 width=14) (actual time=0.015..0.016 rows=1 loops=1)
                     Join Filter: (halls.id = sessions.hall_id)
                     ->  Index Scan using sessions_pkey on sessions  (cost=0.29..8.31 rows=1 width=10) (actual time=0.009..0.010 rows=1 loops=1)
                           Index Cond: (id = 2001)
                     ->  Seq Scan on halls  (cost=0.00..1.03 rows=3 width=4) (actual time=0.001..0.001 rows=1 loops=1)
   ->  Hash  (cost=4.45..4.45 rows=2 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: 8kB
         ->  Index Only Scan using sales_session_id_seat_id_key on sales  (cost=0.42..4.45 rows=2 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Index Cond: (session_id = 2001)
               Heap Fetches: 0

Planning Time: 1.831 ms
Execution Time: 0.168 ms

(19 rows)
```

Комментарий:

"Стоимость" запроса не изменилась, скорость ответа стала немного быстрее.
