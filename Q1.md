# Запрос №1: Выбор всех фильмов на сегодня

# Оптимизация:

Добавлены индексы на колонки, которые используются в качестве внешних ключей:

- `sessions.movie_id`

Добавлен индекс на колонку `date_start` таблицы `sessions`.

## 1.000 записей

До оптимизации:

```postgresql
Subquery Scan on q_1_today_movies  (cost=39.82..39.83 rows=1 width=13) (actual time=0.356..0.358 rows=0 loops=1)
   ->  Sort  (cost=39.82..39.82 rows=1 width=21) (actual time=0.355..0.355 rows=0 loops=1)
         Sort Key: sessions.date_start
         Sort Method: quicksort  Memory: 25kB
         ->  Nested Loop  (cost=0.28..39.81 rows=1 width=21) (actual time=0.334..0.335 rows=0 loops=1)
               ->  Seq Scan on sessions  (cost=0.00..31.50 rows=1 width=16) (actual time=0.330..0.330 rows=0 loops=1)
                     Filter: ((date_start >= now()) AND (date_start <= (CURRENT_DATE + '1 day'::interval)))
                     Rows Removed by Filter: 1000
               ->  Index Scan using movies_pkey on movies  (cost=0.28..8.29 rows=1 width=21) (never executed)
                     Index Cond: (id = sessions.movie_id)

Planning Time: 1.270 ms
Execution Time: 0.387 ms

(12 rows)
```

После оптимизации:

```postgresql
Subquery Scan on q_1_today_movies  (cost=0.43..16.50 rows=1 width=13) (actual time=0.037..0.038 rows=0 loops=1)
   ->  Nested Loop  (cost=0.43..16.49 rows=1 width=21) (actual time=0.035..0.035 rows=0 loops=1)
         ->  Index Scan using idx_sessions_date_start on sessions  (cost=0.16..8.18 rows=1 width=16) (actual time=0.032..0.032 rows=0 loops=1)
               Index Cond: ((date_start >= now()) AND (date_start <= (CURRENT_DATE + '1 day'::interval)))
         ->  Index Scan using movies_pkey on movies  (cost=0.28..8.29 rows=1 width=21) (never executed)
               Index Cond: (id = sessions.movie_id)

Planning Time: 2.176 ms
Execution Time: 0.113 ms

(8 rows)
```

Комментарий:

"Стоимость" запроса уменьшилась, скорость ответа стала немного быстрее.

## 10.000 записей

До оптимизации:

```postgresql
Subquery Scan on q_1_today_movies  (cost=317.31..317.33 rows=1 width=13) (actual time=3.480..3.482 rows=0 loops=1)
   ->  Sort  (cost=317.31..317.32 rows=1 width=21) (actual time=3.479..3.480 rows=0 loops=1)
         Sort Key: sessions.date_start
         Sort Method: quicksort  Memory: 25kB
         ->  Nested Loop  (cost=0.29..317.30 rows=1 width=21) (actual time=3.461..3.462 rows=0 loops=1)
               ->  Seq Scan on sessions  (cost=0.00..309.00 rows=1 width=16) (actual time=3.459..3.459 rows=0 loops=1)
                     Filter: ((date_start >= now()) AND (date_start <= (CURRENT_DATE + '1 day'::interval)))
                     Rows Removed by Filter: 10000
               ->  Index Scan using movies_pkey on movies  (cost=0.29..8.30 rows=1 width=21) (never executed)
                     Index Cond: (id = sessions.movie_id)

Planning Time: 0.979 ms
Execution Time: 3.525 ms

(12 rows)
```

После оптимизации:

```postgresql
Subquery Scan on q_1_today_movies  (cost=317.31..317.33 rows=1 width=13) (actual time=3.312..3.314 rows=0 loops=1)
   ->  Sort  (cost=317.31..317.32 rows=1 width=21) (actual time=3.310..3.311 rows=0 loops=1)
         Sort Key: sessions.date_start
         Sort Method: quicksort  Memory: 25kB
         ->  Nested Loop  (cost=0.29..317.30 rows=1 width=21) (actual time=3.302..3.303 rows=0 loops=1)
               ->  Seq Scan on sessions  (cost=0.00..309.00 rows=1 width=16) (actual time=3.299..3.299 rows=0 loops=1)
                     Filter: ((date_start >= now()) AND (date_start <= (CURRENT_DATE + '1 day'::interval)))
                     Rows Removed by Filter: 10000
               ->  Index Scan using movies_pkey on movies  (cost=0.29..8.30 rows=1 width=21) (never executed)
                     Index Cond: (id = sessions.movie_id)

Planning Time: 0.397 ms
Execution Time: 3.349 ms

(12 rows)
```

Комментарий:

"Стоимость" запроса не изменилась, скорость ответа стала немного быстрее.

## 100.000 записей

До оптимизации:

```postgresql
Subquery Scan on q_1_today_movies  (cost=3092.32..3092.34 rows=1 width=13) (actual time=31.527..31.530 rows=0 loops=1)
   ->  Sort  (cost=3092.32..3092.33 rows=1 width=21) (actual time=31.524..31.526 rows=0 loops=1)
         Sort Key: sessions.date_start
         Sort Method: quicksort  Memory: 25kB
         ->  Nested Loop  (cost=0.29..3092.31 rows=1 width=21) (actual time=31.496..31.498 rows=0 loops=1)
               ->  Seq Scan on sessions  (cost=0.00..3084.00 rows=1 width=16) (actual time=31.471..31.472 rows=0 loops=1)
                     Filter: ((date_start >= now()) AND (date_start <= (CURRENT_DATE + '1 day'::interval)))
                     Rows Removed by Filter: 100000
               ->  Index Scan using movies_pkey on movies  (cost=0.29..8.31 rows=1 width=21) (never executed)
                     Index Cond: (id = sessions.movie_id)

Planning Time: 2.632 ms
Execution Time: 31.606 ms

(12 rows)
```

После оптимизации:

```postgresql
Subquery Scan on q_1_today_movies  (cost=0.59..16.64 rows=1 width=13) (actual time=0.110..0.111 rows=0 loops=1)
   ->  Nested Loop  (cost=0.59..16.63 rows=1 width=21) (actual time=0.107..0.107 rows=0 loops=1)
         ->  Index Scan using idx_sessions_date_start on sessions  (cost=0.30..8.32 rows=1 width=16) (actual time=0.104..0.104 rows=0 loops=1)
               Index Cond: ((date_start >= now()) AND (date_start <= (CURRENT_DATE + '1 day'::interval)))
         ->  Index Scan using movies_pkey on movies  (cost=0.29..8.31 rows=1 width=21) (never executed)
               Index Cond: (id = sessions.movie_id)

Planning Time: 1.667 ms
Execution Time: 0.174 ms

(8 rows)
```

Комментарий:

"Стоимость" запроса значительно уменьшилась, скорость ответа стала значительно быстрее.
