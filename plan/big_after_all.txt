-- 1. Выбор всех фильмов на сегодня

cinema=# explain select m.name
from public.movie m
where m.start_date <= current_date and m.last_date is null;
                            QUERY PLAN
------------------------------------------------------------------
 Seq Scan on movie m  (cost=0.00..1.75 rows=50 width=8)
   Filter: ((last_date IS NULL) AND (start_date <= CURRENT_DATE))
(2 rows)


-- 2. Подсчёт проданных билетов за неделю

cinema=# explain select m.name
from public.movie m
where m.start_date <= current_date and m.last_date is null;
                            QUERY PLAN
------------------------------------------------------------------
 Seq Scan on movie m  (cost=0.00..1.75 rows=50 width=8)
   Filter: ((last_date IS NULL) AND (start_date <= CURRENT_DATE))
(2 rows)

cinema=# explain select count(*) as total
from public.ticket t
where t.date >= (current_date - 6) and t.date <= current_date;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=10841.87..10841.88 rows=1 width=8)
   ->  Gather  (cost=10841.65..10841.86 rows=2 width=8)
         Workers Planned: 2
         ->  Partial Aggregate  (cost=9841.65..9841.66 rows=1 width=8)
               ->  Parallel Index Only Scan using ticket_date on ticket t  (cost=0.44..9290.61 rows=220417 width=0)
                     Index Cond: ((date >= (CURRENT_DATE - 6)) AND (date <= CURRENT_DATE))
(6 rows)


-- 3. Формирование афиши (фильмы, которые показывают сегодня)

cinema=# explain select m.name as movie, c.name as country, m.duration, m.description, string_agg(g.name, ', ')
from public.movie m
inner join public.country c on c.id = m.country_id
left join public.movie_genre mg on m.id = mg.movie_id
left join public.genre g on g.id = mg.genre_id
where m.start_date <= current_date and m.last_date is null
group by m.name, c.name, m.duration, m.description
order by m.name;
                                                        QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=183.53..239.63 rows=2040 width=1074)
   Group Key: m.name, c.name, m.duration, m.description
   ->  Sort  (cost=183.53..188.63 rows=2040 width=1316)
         Sort Key: m.name, c.name, m.duration, m.description
         ->  Hash Left Join  (cost=22.79..71.39 rows=2040 width=1316)
               Hash Cond: (mg.genre_id = g.id)
               ->  Hash Right Join  (cost=6.94..50.09 rows=2040 width=1046)
                     Hash Cond: (mg.movie_id = m.id)
                     ->  Seq Scan on movie_genre mg  (cost=0.00..30.40 rows=2040 width=12)
                     ->  Hash  (cost=6.32..6.32 rows=50 width=1050)
                           ->  Nested Loop  (cost=0.15..6.32 rows=50 width=1050)
                                 ->  Seq Scan on movie m  (cost=0.00..1.75 rows=50 width=536)
                                       Filter: ((last_date IS NULL) AND (start_date <= CURRENT_DATE))
                                 ->  Memoize  (cost=0.15..1.13 rows=1 width=518)
                                       Cache Key: m.country_id
                                       Cache Mode: logical
                                       ->  Index Scan using country_pkey on country c  (cost=0.14..1.12 rows=1 width=518)
                                             Index Cond: (id = m.country_id)
               ->  Hash  (cost=12.60..12.60 rows=260 width=276)
                     ->  Seq Scan on genre g  (cost=0.00..12.60 rows=260 width=276)
(20 rows)




-- 4. Поиск 3 самых прибыльных фильмов за неделю

cinema=# explain select movie, SUM(subtotal) as total
from (
    select (count(t.*) * s.price) as subtotal, m.name as movie
    from public.ticket t
    inner join public.session s on t.session_id = s.id
    inner join public.movie m on s.movie_id = m.id
    where t.date <= current_date and t.date >= (current_date - 6)
    group by t.session_id, s.price, m.name
) as subquery
group by movie
order by total DESC
limit 3;
                                                                     QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=99150.14..99150.14 rows=3 width=40)
   ->  Sort  (cost=99150.14..99150.64 rows=200 width=40)
         Sort Key: (sum((((count(t.*))::numeric * s.price)))) DESC
         ->  HashAggregate  (cost=99145.05..99147.55 rows=200 width=40)
               Group Key: m.name
               ->  Finalize GroupAggregate  (cost=44036.91..96445.05 rows=180000 width=53)
                     Group Key: t.session_id, s.price, m.name
                     ->  Gather Merge  (cost=44036.91..90145.05 rows=360000 width=29)
                           Workers Planned: 2
                           ->  Partial GroupAggregate  (cost=43036.88..47592.09 rows=180000 width=29)
                                 Group Key: t.session_id, s.price, m.name
                                 ->  Sort  (cost=43036.88..43587.92 rows=220417 width=67)
                                       Sort Key: t.session_id, s.price, m.name
                                       ->  Hash Join  (cost=39.57..14431.01 rows=220417 width=67)
                                             Hash Cond: (s.movie_id = m.id)
                                             ->  Hash Join  (cost=37.44..13801.25 rows=220417 width=67)
                                                   Hash Cond: (t.session_id = s.id)
                                                   ->  Parallel Index Scan using ticket_date on ticket t  (cost=0.44..13183.61 rows=220417 width=54)
                                                         Index Cond: ((date <= CURRENT_DATE) AND (date >= (CURRENT_DATE - 6)))
                                                   ->  Hash  (cost=22.00..22.00 rows=1200 width=21)
                                                         ->  Seq Scan on session s  (cost=0.00..22.00 rows=1200 width=21)
                                             ->  Hash  (cost=1.50..1.50 rows=50 width=16)
                                                   ->  Seq Scan on movie m  (cost=0.00..1.50 rows=50 width=16)
(23 rows)



-- 5. Сформировать схему зала и показать на ней свободные и занятые места на конкретный сеанс

cinema=# explain select s.id, s.row_number as row, s.seat_number as number,
    case
        when t.session_id is null then false
        else true
    end as is_sold
from public.seat s
left join public.ticket t on s.id = t.seat_id and t.session_id = 9263 and t.date = current_date
order by s.id;
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Merge Left Join  (cost=3.81..9.99 rows=60 width=7)
   Merge Cond: (s.id = t.seat_id)
   ->  Sort  (cost=3.37..3.52 rows=60 width=6)
         Sort Key: s.id
         ->  Seq Scan on seat s  (cost=0.00..1.60 rows=60 width=6)
   ->  Index Only Scan using ticket_pk on ticket t  (cost=0.44..5.60 rows=58 width=10)
         Index Cond: ((date = CURRENT_DATE) AND (session_id = 9263))
(7 rows)




-- 6. Вывести диапазон миниальной и максимальной цены за билет на конкретный сеанс

cinema=# explain select min(s.price) as min, max(s.price) as max
from public.session s
where s.movie_id = (
    select s.movie_id from session s where s.id = 9253
)
group by s.movie_id;
                                       QUERY PLAN
----------------------------------------------------------------------------------------
 GroupAggregate  (cost=8.29..33.43 rows=1 width=72)
   InitPlan 1 (returns $0)
     ->  Index Scan using session_pkey on session s_1  (cost=0.28..8.29 rows=1 width=8)
           Index Cond: (id = 9253)
   ->  Seq Scan on session s  (cost=0.00..25.00 rows=24 width=13)
         Filter: (movie_id = $0)
(6 rows)



