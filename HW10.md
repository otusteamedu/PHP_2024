# HW10

## Цель

Научиться повышать производительность сервера БД на уровне администрирования настроек.

### В базе данных используются следующие таблицы:

1. `movies` - таблица с фильмами.
2. `attribute_types` - таблица с типами атрибутов.
3. `attributes` - таблица с атрибутами фильмов.
4. `values` - таблица со значениями атрибутов.

### Создание таблиц

```sql
-- Таблица фильмов
CREATE TABLE movies
(
    id    SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL
);

-- Таблица типов атрибутов
CREATE TABLE attribute_types
(
    id        SERIAL PRIMARY KEY,
    name      VARCHAR(255) NOT NULL,
    data_type VARCHAR(50)  NOT NULL
);

-- Таблица атрибутов
CREATE TABLE attributes
(
    id                SERIAL PRIMARY KEY,
    movie_id          INT          NOT NULL,
    attribute_type_id INT          NOT NULL,
    name              VARCHAR(255) NOT NULL,
    FOREIGN KEY (movie_id) REFERENCES movies (id),
    FOREIGN KEY (attribute_type_id) REFERENCES attribute_types (id)
);

-- Таблица значений
CREATE TABLE values
(
    id            SERIAL PRIMARY KEY,
    attribute_id  INT NOT NULL,
    text_value    TEXT,
    boolean_value BOOLEAN,
    date_value    DATE,
    float_value   FLOAT,
    int_value     INT,
    FOREIGN KEY (attribute_id) REFERENCES attributes (id)
);

-- Таблица билетов
CREATE TABLE tickets
(
    id       SERIAL PRIMARY KEY,
    movie_id INT         NOT NULL,
    seat     VARCHAR(10) NOT NULL,
    price    FLOAT       NOT NULL,
    sold_at  TIMESTAMP   NOT NULL,
    FOREIGN KEY (movie_id) REFERENCES movies (id)
);

-- Таблица сеансов
CREATE TABLE screenings
(
    id             SERIAL PRIMARY KEY,
    movie_id       INT       NOT NULL,
    screening_time TIMESTAMP NOT NULL,
    FOREIGN KEY (movie_id) REFERENCES movies (id)
);

-- Таблица залов
CREATE TABLE halls
(
    id   SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

-- Таблица мест в зале
CREATE TABLE seats
(
    id      SERIAL PRIMARY KEY,
    hall_id INT         NOT NULL,
    seat_no VARCHAR(10) NOT NULL,
    FOREIGN KEY (hall_id) REFERENCES halls (id)
);

-- Таблица занятости мест
CREATE TABLE seat_occupancy
(
    id           SERIAL PRIMARY KEY,
    screening_id INT     NOT NULL,
    seat_id      INT     NOT NULL,
    occupied     BOOLEAN NOT NULL,
    FOREIGN KEY (screening_id) REFERENCES screenings (id),
    FOREIGN KEY (seat_id) REFERENCES seats (id)
);
```

### Вставка данных

```sql
-- Заполнение таблиц данными

-- Типы атрибутов
INSERT INTO attribute_types (name, data_type)
VALUES ('рецензии', 'text'),
       ('премия', 'boolean'),
       ('важные даты', 'date'),
       ('служебные даты', 'date'),
       ('числовые значения', 'int');

-- Фильмы
INSERT INTO movies (title)
VALUES ('The Shawshank Redemption'),
       ('The Godfather'),
       ('Pulp Fiction');

-- Атрибуты и значения для фильмов
INSERT INTO attributes (movie_id, attribute_type_id, name)
VALUES
-- The Shawshank Redemption
(1, (SELECT id FROM attribute_types WHERE name = 'рецензии'), 'Рецензия критиков'),
(1, (SELECT id FROM attribute_types WHERE name = 'премия'), 'Оскар'),
(1, (SELECT id FROM attribute_types WHERE name = 'важные даты'), 'Мировая премьера'),
(1, (SELECT id FROM attribute_types WHERE name = 'служебные даты'), 'Дата начала продажи билетов'),
(1, (SELECT id FROM attribute_types WHERE name = 'служебные даты'), 'Когда запускать рекламу на ТВ'),
(1, (SELECT id FROM attribute_types WHERE name = 'числовые значения'), 'Количество наград'),
-- The Godfather
(2, (SELECT id FROM attribute_types WHERE name = 'рецензии'), 'Рецензия критиков'),
(2, (SELECT id FROM attribute_types WHERE name = 'премия'), 'Оскар'),
(2, (SELECT id FROM attribute_types WHERE name = 'важные даты'), 'Мировая премьера'),
(2, (SELECT id FROM attribute_types WHERE name = 'служебные даты'), 'Дата начала продажи билетов'),
(2, (SELECT id FROM attribute_types WHERE name = 'служебные даты'), 'Когда запускать рекламу на ТВ'),
(2, (SELECT id FROM attribute_types WHERE name = 'числовые значения'), 'Количество наград'),
-- Pulp Fiction
(3, (SELECT id FROM attribute_types WHERE name = 'рецензии'), 'Рецензия критиков'),
(3, (SELECT id FROM attribute_types WHERE name = 'премия'), 'Оскар'),
(3, (SELECT id FROM attribute_types WHERE name = 'важные даты'), 'Мировая премьера'),
(3, (SELECT id FROM attribute_types WHERE name = 'служебные даты'), 'Дата начала продажи билетов'),
(3, (SELECT id FROM attribute_types WHERE name = 'служебные даты'), 'Когда запускать рекламу на ТВ'),
(3, (SELECT id FROM attribute_types WHERE name = 'числовые значения'), 'Количество наград');

-- Значения атрибутов
INSERT INTO values (attribute_id, text_value)
VALUES ((SELECT id FROM attributes WHERE movie_id = 1 AND name = 'Рецензия критиков'),
        'An inspiring story of hope and friendship.'),
       ((SELECT id FROM attributes WHERE movie_id = 2 AND name = 'Рецензия критиков'),
        'A masterpiece of crime drama.'),
       ((SELECT id FROM attributes WHERE movie_id = 3 AND name = 'Рецензия критиков'),
        'A wildly original and entertaining film.');
INSERT INTO values (attribute_id, boolean_value)
VALUES ((SELECT id FROM attributes WHERE movie_id = 1 AND name = 'Оскар'), FALSE),
       ((SELECT id FROM attributes WHERE movie_id = 2 AND name = 'Оскар'), TRUE),
       ((SELECT id FROM attributes WHERE movie_id = 3 AND name = 'Оскар'), TRUE);
INSERT INTO values (attribute_id, date_value)
VALUES ((SELECT id FROM attributes WHERE movie_id = 1 AND name = 'Мировая премьера'), '1994-09-10'),
       ((SELECT id FROM attributes WHERE movie_id = 1 AND name = 'Дата начала продажи билетов'), '1994-08-01'),
       ((SELECT id FROM attributes WHERE movie_id = 1 AND name = 'Когда запускать рекламу на ТВ'), '1994-07-01'),
       ((SELECT id FROM attributes WHERE movie_id = 2 AND name = 'Мировая премьера'), '1972-03-15'),
       ((SELECT id FROM attributes WHERE movie_id = 2 AND name = 'Дата начала продажи билетов'), '1972-02-01'),
       ((SELECT id FROM attributes WHERE movie_id = 2 AND name = 'Когда запускать рекламу на ТВ'), '1972-01-01'),
       ((SELECT id FROM attributes WHERE movie_id = 3 AND name = 'Мировая премьера'), '1994-05-21'),
       ((SELECT id FROM attributes WHERE movie_id = 3 AND name = 'Дата начала продажи билетов'), '1994-04-01'),
       ((SELECT id FROM attributes WHERE movie_id = 3 AND name = 'Когда запускать рекламу на ТВ'), '1994-03-01');
INSERT INTO values (attribute_id, int_value)
VALUES ((SELECT id FROM attributes WHERE movie_id = 1 AND name = 'Количество наград'), 7),
       ((SELECT id FROM attributes WHERE movie_id = 2 AND name = 'Количество наград'), 11),
       ((SELECT id FROM attributes WHERE movie_id = 3 AND name = 'Количество наград'), 5);

-- Заполнение билетов
INSERT INTO tickets (movie_id, seat, price, sold_at)
VALUES
-- The Shawshank Redemption
(1, 'A1', 10.0, '2024-06-01 14:30:00'),
(1, 'A2', 10.0, '2024-06-01 14:30:00'),
(1, 'A3', 10.0, '2024-06-01 14:30:00'),
-- The Godfather
(2, 'B1', 12.0, '2024-06-02 16:00:00'),
(2, 'B2', 12.0, '2024-06-02 16:00:00'),
(2, 'B3', 12.0, '2024-06-02 16:00:00'),
-- Pulp Fiction
(3, 'C1', 15.0, '2024-06-03 18:00:00'),
(3, 'C2', 15.0, '2024-06-03 18:00:00'),
(3, 'C3', 15.0, '2024-06-03 18:00:00');

-- Заполнение сеансов
INSERT INTO screenings (movie_id, screening_time)
VALUES
    (1, '2024-06-01 14:30:00'),
    (2, '2024-06-02 16:00:00'),
    (3, '2024-06-03 18:00:00');

-- Заполнение залов
INSERT INTO halls (name)
VALUES ('Hall 1'),
       ('Hall 2'),
       ('Hall 3');

-- Заполнение мест в зале
INSERT INTO seats (hall_id, seat_no)
VALUES
    (1, 'A1'), (1, 'A2'), (1, 'A3'),
    (2, 'B1'), (2, 'B2'), (2, 'B3'),
    (3, 'C1'), (3, 'C2'), (3, 'C3');

-- Заполнение занятости мест
INSERT INTO seat_occupancy (screening_id, seat_id, occupied)
VALUES
-- The Shawshank Redemption
((SELECT id FROM screenings WHERE movie_id = 1 AND screening_time = '2024-06-01 14:30:00'), (SELECT id FROM seats WHERE hall_id = 1 AND seat_no = 'A1'), TRUE),
((SELECT id FROM screenings WHERE movie_id = 1 AND screening_time = '2024-06-01 14:30:00'), (SELECT id FROM seats WHERE hall_id = 1 AND seat_no = 'A2'), FALSE),
((SELECT id FROM screenings WHERE movie_id = 1 AND screening_time = '2024-06-01 14:30:00'), (SELECT id FROM seats WHERE hall_id = 1 AND seat_no = 'A3'), TRUE),
-- The Godfather
((SELECT id FROM screenings WHERE movie_id = 2 AND screening_time = '2024-06-02 16:00:00'), (SELECT id FROM seats WHERE hall_id = 2 AND seat_no = 'B1'), TRUE),
((SELECT id FROM screenings WHERE movie_id = 2 AND screening_time = '2024-06-02 16:00:00'), (SELECT id FROM seats WHERE hall_id = 2 AND seat_no = 'B2'), TRUE),
((SELECT id FROM screenings WHERE movie_id = 2 AND screening_time = '2024-06-02 16:00:00'), (SELECT id FROM seats WHERE hall_id = 2 AND seat_no = 'B3'), FALSE),
-- Pulp Fiction
((SELECT id FROM screenings WHERE movie_id = 3 AND screening_time = '2024-06-03 18:00:00'), (SELECT id FROM seats WHERE hall_id = 3 AND seat_no = 'C1'), TRUE),
((SELECT id FROM screenings WHERE movie_id = 3 AND screening_time = '2024-06-03 18:00:00'), (SELECT id FROM seats WHERE hall_id = 3 AND seat_no = 'C2'), TRUE),
((SELECT id FROM screenings WHERE movie_id = 3 AND screening_time = '2024-06-03 18:00:00'), (SELECT id FROM seats WHERE hall_id = 3 AND seat_no = 'C3'), FALSE);
```

### Запросы для анализа производительности

```sql
-- Выбор всех фильмов на сегодня
SELECT *
FROM movies
         JOIN screenings ON movies.id = screenings.movie_id
WHERE DATE (screenings.screening_time) = CURRENT_DATE;

-- Подсчёт проданных билетов за неделю
SELECT COUNT(*) AS tickets_sold
FROM tickets
WHERE sold_at >= CURRENT_DATE - INTERVAL '7 days';

-- Формирование афиши
SELECT movies.title, screenings.screening_time
FROM movies
         JOIN screenings ON movies.id = screenings.movie_id
WHERE DATE (screenings.screening_time) = CURRENT_DATE;

-- Поиск 3 самых прибыльных фильмов за неделю
SELECT movies.title, SUM(tickets.price) AS total_revenue
FROM tickets
         JOIN movies ON tickets.movie_id = movies.id
WHERE tickets.sold_at >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY movies.title
ORDER BY total_revenue DESC
    LIMIT 3;

-- Сформировать схему зала и показать на ней свободные и занятые места на конкретный сеанс
SELECT seats.seat_no, seat_occupancy.occupied
FROM seats
         JOIN seat_occupancy ON seats.id = seat_occupancy.seat_id
WHERE seat_occupancy.screening_id = < ID_SEANS >;

-- Вывести диапазон минимальной и максимальной цены за билет на конкретный сеанс
SELECT MIN(price) AS min_price, MAX(price) AS max_price
FROM tickets
WHERE movie_id = < ID_FILM >
  AND screening_time = < TIME_SEANS >;
```

### Заполнение таблиц большим количеством данных

```sql
-- Пример для увеличения количества данных до 10000 строк
DO
$$
BEGIN
FOR i IN 1..10000 LOOP
        INSERT INTO movies (title) VALUES ('Movie ' || i);
INSERT INTO tickets (movie_id, seat, price, sold_at)
VALUES (i, 'A' || i % 10, i % 20 + 5, NOW());
INSERT INTO screenings (movie_id, screening_time)
VALUES (i, NOW());
END LOOP;
END $$;

-- Пример для увеличения количества данных до 10000000 строк
DO
$$
BEGIN
FOR i IN 1..10000000 LOOP
        INSERT INTO movies (title) VALUES ('Movie ' || i);
INSERT INTO tickets (movie_id, seat, price, sold_at)
VALUES (i, 'A' || i % 10, i % 20 + 5, NOW());
INSERT INTO screenings (movie_id, screening_time)
VALUES (i, NOW());
END LOOP;
END $$;
```

### Проведение анализа производительности

```sql
EXPLAIN
ANALYZE
SELECT *
FROM movies
         JOIN screenings ON movies.id = screenings.movie_id
WHERE DATE (screenings.screening_time) = CURRENT_DATE;
```

## Результат трех анализов до применения индексов

```text
На основании представленных данных выполнения запросов до применения индексов, можно увидеть, 
что запросы выполняются довольно долго, несмотря на использование параллельных последовательных 
сканирований и индексов по первичным ключам.
________________________________________________________________
Gather  (cost=1000.43..245813.34 rows=50001 width=33) (actual time=14.912..5983.058 rows=10000000 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Nested Loop  (cost=0.43..239813.24 rows=20834 width=33) (actual time=24.788..5624.161 rows=3333333 loops=3)
        ->  Parallel Seq Scan on screenings  (cost=0.00..126972.94 rows=20834 width=16) (actual time=24.142..825.966 rows=3333333 loops=3)
              Filter: (date(screening_time) = CURRENT_DATE)
              Rows Removed by Filter: 1
        ->  Index Scan using movies_pkey on movies  (cost=0.43..5.42 rows=1 width=17) (actual time=0.001..0.001 rows=1 loops=10000000)
              Index Cond: (id = screenings.movie_id)
Planning Time: 33.927 ms
JIT:
  Functions: 24
"  Options: Inlining false, Optimization false, Expressions true, Deforming true"
"  Timing: Generation 7.056 ms, Inlining 0.000 ms, Optimization 2.823 ms, Emission 17.729 ms, Total 27.608 ms"
Execution Time: 6217.532 ms
________________________________________________________________
Gather  (cost=1000.43..245813.34 rows=50001 width=33) (actual time=10.021..5192.711 rows=10000000 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Nested Loop  (cost=0.43..239813.24 rows=20834 width=33) (actual time=14.796..4840.472 rows=3333333 loops=3)
        ->  Parallel Seq Scan on screenings  (cost=0.00..126972.94 rows=20834 width=16) (actual time=4.976..986.659 rows=3333333 loops=3)
              Filter: (date(screening_time) = CURRENT_DATE)
              Rows Removed by Filter: 1
        ->  Index Scan using movies_pkey on movies  (cost=0.43..5.42 rows=1 width=17) (actual time=0.001..0.001 rows=1 loops=10000000)
              Index Cond: (id = screenings.movie_id)
Planning Time: 13.346 ms
JIT:
  Functions: 24
"  Options: Inlining false, Optimization false, Expressions true, Deforming true"
"  Timing: Generation 7.431 ms, Inlining 0.000 ms, Optimization 1.520 ms, Emission 12.285 ms, Total 21.236 ms"
Execution Time: 5438.550 ms
________________________________________________________________
Gather  (cost=1000.43..245813.34 rows=50001 width=33) (actual time=10.243..4593.358 rows=10000000 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Nested Loop  (cost=0.43..239813.24 rows=20834 width=33) (actual time=17.559..4260.266 rows=3333333 loops=3)
        ->  Parallel Seq Scan on screenings  (cost=0.00..126972.94 rows=20834 width=16) (actual time=4.941..771.247 rows=3333333 loops=3)
              Filter: (date(screening_time) = CURRENT_DATE)
              Rows Removed by Filter: 1
        ->  Index Scan using movies_pkey on movies  (cost=0.43..5.42 rows=1 width=17) (actual time=0.001..0.001 rows=1 loops=10000000)
              Index Cond: (id = screenings.movie_id)
Planning Time: 41.651 ms
JIT:
  Functions: 24
"  Options: Inlining false, Optimization false, Expressions true, Deforming true"
"  Timing: Generation 5.393 ms, Inlining 0.000 ms, Optimization 1.314 ms, Emission 12.464 ms, Total 19.171 ms"
Execution Time: 4824.658 ms
```

### Оптимизация

```sql
-- Для оптимизации фильтрации по дате:
CREATE INDEX idx_screening_time ON screenings(screening_time);
-- Для оптимизации подсчета проданных билетов за неделю:
CREATE INDEX idx_sold_at ON tickets(sold_at);
-- Для ускорения объединений:
CREATE INDEX idx_tickets_movie_id ON tickets(movie_id);
-- Для ускорения объединений:
CREATE INDEX idx_screenings_movie_id ON screenings(movie_id);
-- Для оптимизации запросов, связанных с занятостью мест на конкретный сеанс:
CREATE INDEX idx_seat_occupancy_screening_id ON seat_occupancy(screening_id);
-- Для оптимизации запросов, связанных с местами в зале:
CREATE INDEX idx_seats_hall_id_seat_no ON seats(hall_id, seat_no);
-- Для ускорения объединений и выборок по таблице movies:
CREATE INDEX idx_movies_id_title ON movies(id, title);
-- Для ускорения выборок атрибутов фильмов:
CREATE INDEX idx_attributes_movie_id_attribute_type_id ON attributes(movie_id, attribute_type_id);
-- Для ускорения выборок значений атрибутов:
CREATE INDEX idx_values_attribute_id ON values(attribute_id);
-- Для ускорения выборок по фильму и времени сеанса:
CREATE INDEX idx_screenings_movie_id_screening_time ON screenings(movie_id, screening_time);
-- Для улучшения подсчета проданных билетов по фильму и времени:
CREATE INDEX idx_tickets_movie_id_sold_at ON tickets(movie_id, sold_at);
```

## Результат трех анализов после применения индексов

```text
________________________________________________________________
Gather  (cost=1000.43..197702.74 rows=50000 width=33) (actual time=22.202..3929.735 rows=10000000 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Nested Loop  (cost=0.43..191702.74 rows=20833 width=33) (actual time=43.340..3629.326 rows=3333333 loops=3)
        ->  Parallel Seq Scan on screenings  (cost=0.00..126971.69 rows=20833 width=16) (actual time=33.505..741.017 rows=3333333 loops=3)
              Filter: (date(screening_time) = CURRENT_DATE)
              Rows Removed by Filter: 1
        ->  Index Only Scan using idx_movies_id_title on movies  (cost=0.43..3.11 rows=1 width=17) (actual time=0.001..0.001 rows=1 loops=10000000)
              Index Cond: (id = screenings.movie_id)
              Heap Fetches: 0
Planning Time: 5.037 ms
JIT:
  Functions: 18
"  Options: Inlining false, Optimization false, Expressions true, Deforming true"
"  Timing: Generation 6.595 ms, Inlining 0.000 ms, Optimization 2.973 ms, Emission 18.738 ms, Total 28.306 ms"
Execution Time: 4161.872 ms
________________________________________________________________
Gather  (cost=1000.43..197702.74 rows=50000 width=33) (actual time=28.349..3933.962 rows=10000000 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Nested Loop  (cost=0.43..191702.74 rows=20833 width=33) (actual time=35.094..3622.092 rows=3333333 loops=3)
        ->  Parallel Seq Scan on screenings  (cost=0.00..126971.69 rows=20833 width=16) (actual time=25.082..710.306 rows=3333333 loops=3)
              Filter: (date(screening_time) = CURRENT_DATE)
              Rows Removed by Filter: 1
        ->  Index Only Scan using idx_movies_id_title on movies  (cost=0.43..3.11 rows=1 width=17) (actual time=0.001..0.001 rows=1 loops=10000000)
              Index Cond: (id = screenings.movie_id)
              Heap Fetches: 0
Planning Time: 6.253 ms
JIT:
  Functions: 18
"  Options: Inlining false, Optimization false, Expressions true, Deforming true"
"  Timing: Generation 7.992 ms, Inlining 0.000 ms, Optimization 2.702 ms, Emission 25.850 ms, Total 36.544 ms"
Execution Time: 4167.979 ms
________________________________________________________________
Gather  (cost=1000.43..197702.74 rows=50000 width=33) (actual time=17.182..3904.742 rows=10000000 loops=1)
  Workers Planned: 2
  Workers Launched: 2
  ->  Nested Loop  (cost=0.43..191702.74 rows=20833 width=33) (actual time=31.735..3603.372 rows=3333333 loops=3)
        ->  Parallel Seq Scan on screenings  (cost=0.00..126971.69 rows=20833 width=16) (actual time=22.763..728.734 rows=3333333 loops=3)
              Filter: (date(screening_time) = CURRENT_DATE)
              Rows Removed by Filter: 1
        ->  Index Only Scan using idx_movies_id_title on movies  (cost=0.43..3.11 rows=1 width=17) (actual time=0.001..0.001 rows=1 loops=10000000)
              Index Cond: (id = screenings.movie_id)
              Heap Fetches: 0
Planning Time: 5.666 ms
JIT:
  Functions: 18
"  Options: Inlining false, Optimization false, Expressions true, Deforming true"
"  Timing: Generation 6.702 ms, Inlining 0.000 ms, Optimization 1.738 ms, Emission 18.709 ms, Total 27.150 ms"
Execution Time: 4134.429 ms
```

### Анализ результатов до и после применения индексов

```text
Результаты до применения индексов
1. Execution Time: 6217.532 ms
2. Execution Time: 5438.550 ms
3. Execution Time: 4824.658 ms

Результаты после применения индексов
1. Execution Time: 4161.872 ms
2. Execution Time: 4167.979 ms
3. Execution Time: 4134.429 ms

Применение индексов существенно улучшило производительность запросов. Среднее время выполнения запросов 
сократилось на 24.34%, что является значительным улучшением. Дополнительные индексы помогли оптимизировать 
фильтрацию и объединение данных, что привело к более эффективному выполнению запросов.

Настройка параметров, таких как work_mem и shared_buffers, может дополнительно улучшить производительность.
```


### Отсортированный список объектов БД

```sql
-- Самые большие объекты
SELECT relname                                       AS object_name,
       pg_size_pretty(pg_total_relation_size(relid)) AS total_size
FROM pg_catalog.pg_statio_user_tables
ORDER BY pg_total_relation_size(relid) DESC LIMIT 15;

-- Самые часто используемые индексы
SELECT indexrelname AS index_name,
       idx_scan     AS number_of_scans
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC LIMIT 5;

-- Самые редко используемые индексы
SELECT indexrelname AS index_name,
       idx_scan     AS number_of_scans
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC LIMIT 5;
```
